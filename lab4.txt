Task 1)

  What is the output of this code?
it prints "..." num times and then prints blastoff.

  Modify it so that it prints only the even numbers. 
void countDown(int num)

{

      if (num == 0) // test

                  System.out.println("Blastoff!");

       else {

                  if (num % 2 == 0) System.out.println(num);

                    countDown(num-1); // recursive call

             } 

}
  What is the time complexity of this algorithm and why?
It is O(n) because it goes from num to 0.

Task 2)

  What is the output of this code?
It returns the greatest common denominator of x and y

  Modify it to find the gcd using subraction instead of %
int gcd(int x, int y) {

      if (x % y == 0) //base case

             return y;

       else
       {
             int remainder = x; while (remainder > y) remainder -= y;
             return gcd(y, remainder);
       }

}

Task 3)

  What is the time complexity of this algorithm and why?
It is O(2^n) because for each recursive call it calls another two times.





1. Write a function that prints "Hello World" n times recursively. 

void helloWorld(int n)
{
  if (n == 0) return;
  System.out.println("Hello world!");
  return helloWorld(n - 1);
}

2. Write a function that returns the sum of all numbers between n1 and n2 that are multiples of 7 using recursion.

int sumOfMultiplesOfSeven(int n1, int n2)
{
  if (n1 > n2) return 0;
  if (n1 % 7 == 0) return n1 + sumOfMultiplesOfSeven(n1 + 7, n2);
  return sumOfMultiplesOfSeven(n1 + 1, n2);
}

3. Write a function that implements the binary search algorithm recursively.

int binarySearch(int[] arr, int l, int h, int needle)
{
  if (l > h) return -1;
  int med = (l + h) / 2;
  if (arr[med] == needle) return med;
  if (arr[med] > needle) return binarySearch(arr, l, med - 1, needle);
  return binarySearch(arr, med + 1, h, needle);
}
